# Genrative AI


Syllabus for Learning Generative AI with Hands-On Projects
Module 1: Introduction to Generative AI
Topics:

Overview of Generative AI
Applications of Generative AI
Introduction to frameworks: OpenAI and Gemani
Project 1: Getting Started with OpenAI API

Objective: Learn to import and use the OpenAI API.
Tasks:
Set up a Google Colab environment.
Create an OpenAI API key.
Write a Python script to make a simple query to the OpenAI model and process the response.
Resources:
OpenAI API documentation
Google Colab tutorial
Module 2: Data Processing with OpenAI/Gemani
Topics:

Data preprocessing techniques
Using OpenAI and Gemani for data processing
Project 2: Data Processing with OpenAI/Gemani

Objective: Process text data using OpenAI and Gemani APIs.
Tasks:
Import a dataset (e.g., a collection of text documents).
Clean and preprocess the data.
Use OpenAI to generate summaries or perform sentiment analysis on the data.
Resources:
OpenAI API documentation
Gemani documentation
Module 3: Prompt Engineering
Topics:

Introduction to prompt engineering
Techniques to handle bias and prompt injection
Project 3: Learning Prompt Engineering

Objective: Learn to craft effective prompts and evaluate them.
Tasks:
Create prompts for various tasks (e.g., translation, summarization).
Test prompts for bias and refine them.
Evaluate prompt injection scenarios.
Resources:
OpenAI prompt engineering guide
Research papers on bias in AI
Module 4: Training a Small Language Model
Topics:

Basics of training language models
Simple tasks for language models
Project 4: Train a Simple Grammar-Checking Model

Objective: Train a small language model for English grammar checking.
Tasks:
Prepare a dataset for grammar checking.
Train a language model using the dataset.
Evaluate the model's performance.
Resources:
Hugging Face Transformers documentation
Dataset resources (e.g., publicly available grammar datasets)
Module 5: Fine-Tuning an Open Source LLM
Topics:

Fine-tuning techniques for LLMs
Applications of fine-tuned models
Project 5: Fine-Tune an LLM for Sentiment Analysis

Objective: Fine-tune an open-source LLM for sentiment analysis tasks.
Tasks:
Select an open-source LLM (e.g., GPT-2).
Prepare a sentiment analysis dataset.
Fine-tune the model and evaluate its performance.
Resources:
Hugging Face Transformers documentation
Sentiment analysis datasets
Module 6: LLMs with Retrieval-Augmented Generation (RAG)
Topics:

Introduction to RAG
Enhancing LLMs with external knowledge sources
Project 6: Implementing RAG for Specific Knowledge Tasks

Objective: Improve an LLM's performance by integrating RAG.
Tasks:
Set up a retrieval system.
Integrate the retrieval system with the LLM.
Evaluate the performance on specific knowledge tasks.
Resources:
Hugging Face RAG documentation
Research papers on RAG
Module 7: Localizing and Creating a UI for a Trained LLM
Topics:

Localization techniques
Creating user interfaces for AI models
Project 7: Localizing and Building a UI for a Grammar-Checking LLM

Objective: Localize a trained LLM and build a user-friendly interface.
Tasks:
Implement localization for the LLM.
Develop a web-based UI using Flask or Streamlit.
Integrate the LLM with the UI.
Resources:
Flask/Streamlit documentation
Localization resources
Module 8: LLM with Web Search Functionality
Topics:

Integrating web search with LLMs
Applications of web search in AI
Project 8: Building an LLM with Web Search Capabilities

Objective: Create an LLM that can perform web searches and provide answers.
Tasks:
Set up a web search API.
Integrate the web search functionality with the LLM.
Test the LLM's performance in answering queries.
Resources:
Web search API documentation (e.g., Google Custom Search API)
Integration guides
Final Project: Comprehensive LLM Application
Objective: Combine knowledge and skills from all modules to create a comprehensive LLM application.
Tasks:

Define a real-world problem to solve using an LLM.
Utilize data processing, prompt engineering, fine-tuning, RAG, localization, UI development, and web search integration.
Present the final application as part of a project portfolio.
